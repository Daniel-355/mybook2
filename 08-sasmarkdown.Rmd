# SASmarkdown

This section shows how to write **SAS code inside an R Markdown workflow** using the `SASmarkdown` package. The goal is to keep one reproducible document (HTML/PDF) while allowing SAS to do what SAS is good at: data steps, PROC routines, reporting, and macros.

Two ideas drive the design:

1) **knitr engines**: a code chunk can be executed by an external program (SAS) instead of R.  
2) **chunk isolation**: in most SASmarkdown workflows, each SAS chunk runs as its own SAS “session script,” so objects created in one chunk may not automatically exist in another chunk (unless you explicitly write/read datasets).

This is why SASmarkdown feels different from pure SAS Studio and also different from pure R Markdown.

---

## How to install SASmarkdown

The SASmarkdown package and documentation are here:  
[sasmarkdown](https://www.ssc.wisc.edu/~hemken/SASworkshops/Markdown/SASmdpackage.html)

The typical setup steps are:

- Install and load `SASmarkdown` in R.
- Tell knitr where SAS is installed (the `sas.exe` path).
- Set SAS options (log, line size, batch mode).
- Set the chunk engine to a SAS engine such as `sas`, `saslog`, `sashtml`, etc.

---

### Use an engine

The first chunk loads the package. You *can* also set global knitr options here, but the key is that **SASmarkdown must be available**.

```{r libload} 
# knitr::opts_chunk$set(echo = TRUE)
require(SASmarkdown)
```

Next, we define the SAS executable path and options, then tell knitr to use `sashtml` as the default engine.  

What this means operationally:

- knitr writes your SAS code to a temporary `.sas` file,
- calls `sas.exe` in batch mode,
- captures the HTML output produced by SAS,
- embeds that output into your knitted document.

```{r}
saspath <- "C:/Program Files/SASHome/SASFoundation/9.4/sas.exe"
sasopts <- "-nosplash -ls 75"
knitr::opts_chunk$set(engine='sashtml', engine.path=saspath,
                      engine.opts=sasopts, comment="")
```

**Common troubleshooting notes (Windows):**
- If the path contains spaces, it must still be a valid Windows path string.
- If you have multiple SAS versions, confirm the correct `sas.exe`.
- Some corporate environments block batch execution; SASmarkdown may fail unless permissions allow it.

---

## Common statements

Two practical rules matter most when writing SAS inside R Markdown:

1) **Do not use R syntax inside SAS chunks**  
   SAS chunks are sent to SAS verbatim. R objects like `mydata`, `paste()`, or `%>%` have no meaning there.

2) **Data typically cannot be used across chunks unless you persist it**  
   Many SASmarkdown setups run each SAS chunk independently. If you create `data test; ... run;` in one chunk, the next chunk may not “see” `work.test` unless the session is preserved or you write it out to a permanent library.

A safe habit is:
- treat each SAS chunk as self-contained, or
- write datasets to a permanent location/library and read them back later.

---

### Read in data using informats (date data)

#### Example 1: a minimal DATA step with inline data

This example uses `cards; ... ;` to create a dataset directly.  
It is the fastest way to create toy data for teaching, testing, or demonstrations.

```{r , engine="sas" , error=TRUE}
/*import and export raw data using infile*/
data test;

/*infile "c:/document/data.text";*/
input name $ height weight;
length height 4;
cards 
;
Daniel 173 150
;
run;
proc print;run;
```

Key points:
- `input name $ height weight;` declares `name` as character (`$`) and the others numeric.
- `length height 4;` sets storage length (bytes) for numeric variables (mainly useful for character variables; numeric is typically 8 bytes by default in SAS).
- `proc print;` confirms what was read.

---

#### Example 2: reading mixed date strings using `inputn()`

Real-world data often stores dates as text in inconsistent formats.  
Here we read two strings: one containing the date text and one containing the informat name. Then we convert dynamically using `inputn()`.

```{r , engine="sas" , error=TRUE}
data have;
input char_date : $20. fmt : $20.;
/* set a new variable format*/
num_char=inputn(char_date,fmt);
format num_char date9. ;
cards;
12-08-2015  DDMMYY12.
12/8/2016   MMDDYY12.
05/25/2015  MMDDYY12.
;
run;
proc print;run;
```

What’s happening:
- `char_date` is a character date string.
- `fmt` is a character variable holding an informat name (like `DDMMYY12.`).
- `inputn(char_date, fmt)` converts using the informat stored in `fmt`.
- `format num_char date9.;` controls display (e.g., `25MAY2015`).

This pattern is extremely useful in messy ingestion pipelines.

---

#### Example 3: date informat directly in INPUT

If the date format is consistent, you can apply the informat in the `input` statement directly:

```{r , engine="sas" , error=TRUE}
data have;
input char_date MMDDYY10.  ;
/* output format */
format char_date date9. ;
cards;
12-08-2015   
12/8/2016   
05/25/2015   
;
run;
proc print;run;
```

Here:
- SAS reads a date value using `MMDDYY10.` regardless of separator style.
- The stored value is numeric (SAS date = days since 01JAN1960), but displayed via `date9.`.

---

#### Example 4: setting both input and output format consistently

Sometimes you want to keep the same “look” as the input:

```{r , engine="sas" , error=TRUE}
data have;
/* set input and output format*/
input char_date MMDDYY10.  ;
format char_date MMDDYY10. ;
cards;
12-08-2015   
12/8/2016   
05/25/2015   
;
run;
proc print;run;
```

This helps when your deliverable expects a specific format (for example, when exporting to CSV to be read by another system).

---

### Compute mean and frequency

A typical exploratory workflow in SAS uses `proc means`, `proc freq`, and `proc contents`.

```{r , engine="sas" , error=TRUE}
proc means data=sashelp.class maxdec=5 ;
run;

proc freq data=sashelp.class  ;
table sex;
run;

proc contents data=sashelp.class varnum  ;
run;

```

Interpretation:
- `proc means` summarizes numeric variables (mean, std, min, max, etc.).
- `proc freq` tabulates categorical variables.
- `proc contents varnum` shows dataset metadata ordered by variable position.

These are often the first three procs you run when you open a new dataset.

---

### Sort a dataset

Sorting is required for many BY-group operations (including merges and BY processing).

```{r , engine="sas" , error=TRUE}
proc sort data=sashelp.class Out= name ;
by name;
Run;

proc print data= name (obs=10) ;
run;
```

Note:
- The output dataset name `name` is legal but can be confusing because `name` is also a variable in `sashelp.class`.
- A safer convention is `out=class_sorted`, but we keep your code unchanged.

---

### Transpose or reshape

Reshaping appears frequently in reporting and longitudinal data workflows.

#### Wide to long

`proc transpose` converts columns into rows.  

```{r , engine="sas" , error=TRUE}
proc transpose data= sashelp.class out= Field;
by name;
Run;

proc print data= field (obs=10) ;
run;
```

A critical detail:
- BY processing requires sorted data by `name` (or SAS will warn/error depending on settings).

---

#### Long to wide

A second transpose can rebuild a wide layout, typically using:
- `id` to name new columns,
- `var` to specify the values to spread.

```{r , engine="sas" , error=TRUE}
proc transpose data= sashelp.class out= Field;
by name;
Run;

proc transpose data=Field out=Field_wide  ;
    by name ;
    id _name_;
    var col1;
run;

proc print data= field_wide (obs=10) ;
run;
```

Conceptually:
- The first transpose creates a “longer” dataset with `_name_` and `col1`.
- The second transpose pivots `_name_` levels into columns.

---

### Conditional statements

Conditional logic is fundamental in data steps: creating flags, categories, derived variables, and messages.

#### Simple IF/ELSE

```{r , engine="sas" , error=TRUE}
DATA ab;
set sashelp.class;
IF sex="F" then message='A is greater';
Else message='B is greater';
Run; 

proc print data=ab (obs=10);
run;
```

Even though the message text is arbitrary, the example demonstrates:
- IF/ELSE structure,
- character literals in quotes,
- adding derived variables in a data step.

---

#### Multiple conditions (ELSE IF)

```{r , engine="sas" , error=TRUE}
Data class;
set sashelp.class;
if weight >=100 then weight_cat =3;
else if weight >=90 and weight <100 then weight_cat =2 ;
else weight_cat =1;
attrib weight_cat label = "weight category,  1=Inad, 2=Adeq, 3=Exces"; 
run;

proc print data=class (obs=3);
run;
```

This is a standard pattern for category creation:
- ordered thresholds,
- mutually exclusive categories,
- labeling for readable tables.

---

#### `index()` for pattern detection

```{r , engine="sas" , error=TRUE}
data test;
set sashelp.class;
length gender $10 ;
if index(sex,"M")>0 THEN gender="male";
if index(sex,"F")>0 THEN gender="female";
RUN;

proc print data=test (obs=5);
run;
```

Note:
- `index()` returns the position of a substring (0 if not found).
- Because you used two separate IF statements (not IF/ELSE), the logic is still fine here because `sex` can’t be both "M" and "F".

---

### LIKE operation to select rows containing a pattern

SAS `where` supports SQL-like pattern matching using `like` with `%` wildcards.

```{r , engine="sas" , error=TRUE}
proc print data =sashelp.class;
where upcase(name) like '%A%';
run;

proc print data =sashelp.class;
where  (name) like '%A%';
run;
```

The first query is case-insensitive by forcing uppercase.  
The second is case-sensitive, depending on your SAS session settings.

---

### Change format of a variable

User-defined formats map raw values into labeled categories (often for tables).

```{r , engine="sas" , error=TRUE}
proc format;
   value AGEnew
        11 = '1: NEW' 
        12 = '2: NEW'
        13 = '3: NEW' 
        14 = '4: NEW'
        15 = '5: NEW'
        16 = '6: NEW'        
        ;
        run;
        
DATA ab;
set sashelp.class;
Format AGE AGEnew.;
Run;
        
proc freq data=ab;
        table AGE;
        run;
        
```

This workflow is typical:
1) define format in `proc format`,  
2) apply format in a data step,  
3) display with `proc freq`.

---








### Basic operations

SAS provides many numeric functions directly in the data step.

```{r  , engine="sas" , error=TRUE}
Data Mathdata;
A= 10.12345;
B=20;
C= mean (a,b);
D= Min(a,b);
E= Max(a,b); 
F = log(a);
G= round(a,0.02);
H= floor(a );

Run;

proc print data=Mathdata;
run;

Data mathdata;
Set  sashelp.Iris;
Sum = sum (of SepalLength, SepalWIDTH);
Diff = SepalLength- SepalWIDTH;
Mult = SepalLength* SepalWIDTH;
Div= SepalLength/ SepalWIDTH;
Run;

proc print data=mathdata (obs=10);
run;
```

Two common teaching points:
- SAS functions like `mean()` handle missing values differently than plain arithmetic.
- `sum(of ...)` is a very SAS-specific idiom and scales well when many variables are involved.

---

### Rename variables

#### Rename one variable

```{r  , engine="sas" , error=TRUE}
 Data AB;
set sashelp.class; Rename AGE= AGENEW;
Run;

proc print data=AB;
run;
```

#### Rename multiple variables programmatically

This advanced example shows how to build a rename list from `dictionary.columns` and apply it.

```{r  , engine="sas" , error=TRUE}
/*rename*/
data AAA;
 set sashelp.class;
run;

/*create a list*/
proc sql noprint;
   select cats(name,'=',name,'_new')
          into : lis
          separated by ' '
          from dictionary.columns
          where libname = 'WORK' and memname = 'AAA';
quit;
%put &lis;

proc datasets library = work nolist;
   modify AAA;
   rename &lis;
quit;

proc print data=aaa (obs=2);
run;    
          
/*function to deal with text*/
%scan(&lis,2);   
/*#scan variable*/
%substr(NAME, %length(NAME),1);  
/*#extract character*/
%substr(NAME, 2,1);    
%index(&lis,"Age=Age_new") ;         
/*#identify this exists  */
```

Why this matters:
- In real clinical trial pipelines, you often receive datasets with inconsistent naming conventions.
- Generating rename rules programmatically reduces manual error and improves reproducibility.

---

### Text manipulation

#### Extract text from a character value

```{r  , engine="sas" , error=TRUE}
Data Mathdata;
Text = "Hello World";
Text1= substr(Text, 6, 2);
Run;

proc print data=mathdata  ;
run;
```

`substr()` is one of the most-used string functions in clinical reporting.

---

#### Convert character to numeric and reverse

Character → numeric:

```{r , engine="sas" , error=TRUE}
Data ABC;
set sashelp.class;
agenew= input (age, best.); 
Run;

proc print data=abc  ;
run;

```

Numeric → character:

```{r , engine="sas" , error=TRUE}
Data ABC;
set sashelp.class;
agenew= put (age, best.); 
Run;

proc contents data=abc  ;
run;
```

In practice:
- `input()` reads a character string into numeric.
- `put()` formats numeric into character.

---

#### Change the length of a variable

```{r , engine="sas" , error=TRUE}
Data ABC;
set sashelp.class;
Length agenew $10.;
Label agenew=“New age”;
Run;

proc contents data=abc  ;
run;
 
```

A key habit: define `length` before assignment when creating new character variables to avoid truncation.

---

### Create a report

`proc report` is a flexible reporting tool and can replace many `proc print` / `proc tabulate` workflows.

```{r , engine="sas" , error=TRUE}
proc report data=sashelp.class;
Column age;
Define age / display;
Run;
```

Even this minimal example shows the structure:
- `column` defines the layout,
- `define` controls how variables appear.

---

### Random variables

SAS provides pseudo-random generators via `rand()`.

```{r , engine="sas" , error=TRUE}
data ab;
set sashelp.class;
num=rand("normal");
run;

proc print data=ab (obs=10); 
run;
```

This is useful for simulation, multiple imputation diagnostics, and resampling.

---

### Combine two texts, compress spaces, locate a substring, change case

These are common in cleaning messy character fields.

Combine:

```{r , engine="sas" , error=TRUE}
Data Mathdata;
Text = "Hello";
Text1= "World";
Text2= text || " " ||text1;
Run;

proc print data=Mathdata  ; 
run;
```

Compress:

```{r , engine="sas" , error=TRUE}
Data Mathdata;
Text = "Hello  World  ";
Text1= trim(text);
Text2= compress(text);
Run;

proc print data=Mathdata  ; 
run;
```

Index:

```{r , engine="sas" , error=TRUE}
Data Mathdata;
Text = "Hello World";
indextext=  index(text, "or");
Run;

proc print data=Mathdata  ; 
run;
```

Case functions:

```{r , engine="sas" , error=TRUE}
Data Mathdata;
Text = "Hello World";
upcase=  upcase(text );
lowcase=  lowcase(text );
propcase=  propcase(text );
Run;

proc print data=Mathdata  ; 
run;
```

---

### Deduplication

Deduplication is a frequent preprocessing step, especially when identifying unique subjects, visits, or records.

#### Method 1: `nodupkeys`

```{r, engine="sas" , error=TRUE}
proc sort data = sashelp.class out =  dedup
nodupkeys;
by height; 
run;

proc print data= dedup;
run;

```

This keeps the first record for each unique `height`.

#### Method 2: BY-group with `first.` / `last.`

```{r, engine="sas" , error=TRUE}
proc sort data=sashelp.class out=data_rank;  by height  ; run;

data outdata dropdata;
 set data_rank;
 by height ;
 if last.height   then output  outdata;
else output dropdata; 
run;
proc print data=dropdata;run; 
```

This version keeps the last record per `height`.  
Notice that the output depends on the current sort order.

---

### Select a subset of rows

```{r,engine="sas", error=TRUE}
data where;
set sashelp.class;
where sex ne "F";
/*if */
run;

proc print data= where;
run;
```

The `where` statement filters rows during reading, which is typically more efficient than filtering after reading.

---

### Create macros with DO loops

Macros provide automation, especially when the same PROC is repeated across multiple variables.

#### A macro to calculate descriptive stats across multiple variables

This example uses:
- `proc means` to compute summaries by `sex`,
- ODS output to capture results,
- a macro loop to run across variables.

```{r,engine="sas",error=TRUE}
%macro means(var_avg) ;

/*calculate means*/
proc means data=sashelp.class StackODSOutput n mean std  min p5 p95 max nmiss; 
var  &var_avg;
class sex;
ods output summary=result2;
run;

/*append then output*/
data masterresult2;                  * combine results;
set masterresult2 result2;
run;

%mend means;

/*use macro to merge all descriptive stats */
data masterresult2 ;
set _null_;
run;

%let vars= 
age
height
weight
;

%macro model ;
%do i=1 %to %sysfunc(countw(&vars));

%let x=%scan(&vars,&i);
 %means( &x )
 
%end;
%mend model;

%model;

proc print data= masterresult2;
run;

```

Practical interpretation:
- `&vars` defines the batch of variables.
- `%do` iterates through them.
- Each iteration runs `proc means` and appends results into a single dataset.

This is exactly the type of pattern used in clinical reporting pipelines when building shells.

---

### Output intermediate tables with ODS

ODS is the bridge from SAS procedures to reusable datasets.

#### Discover table names: `ods trace`

```{r,engine="sas",error=TRUE}
ods trace on;
proc freq data=sashelp.class  ;
table  sex;
run;
ods trace off;
```

`ods trace` tells you which internal table objects SAS produces.

#### Capture a specific output table

```{r,engine="sas",error=TRUE}
ods   listing close;
ods trace on;
ods output ParameterEstimates= ParameterEstimates  ;
proc glm data=sashelp.class;
model height=age;
run;
ods trace off;
ods listing;

proc print data=ParameterEstimates;
run;

```

This pattern is essential when you want to:
- compute results in SAS,
- feed them into later steps,
- export them, or
- compare them against R outputs.

---

### Create sequence numbers

Sequence variables are common in SDTM/ADaM creation and tracking.

#### Grouped sequence numbers

```{r,engine="sas",error=TRUE}
/* grouped*/
proc sort data=sashelp.class out=class ; by name; run; 
data temp; set class; 
	by name; 
  	count + 1;
	if first.name then count = 1; 
run; 
proc print data=temp (obs=3);run; 


proc sort data=class out=class2 ; by height; run; 
data class3;
set class2;
by height;
retain count;
if first.height then count=1;
else count=count+1;
run;
proc print data=class3 (obs=3);run; 

 /*nogrouped*/
data new;
 set class;
 seqno = _n_;
run;

proc print data=new (obs=3);run; 
```

Key idea:
- `_n_` is the observation index within the data step.
- `first.` and `last.` require sorted data and allow per-group logic.

---

### Merge datasets

SAS has two main approaches:
- SQL joins (`proc sql`) — flexible and readable,
- DATA step `merge` — fast and common in production, but requires sorting and careful logic.

#### Left and right join

```{r,engine="sas",error=TRUE}
data class2;
input name $   score;
datalines;
Alfred 	85
Alice 89
Daniel 99
;
run;

proc sql;
create table class_c as
  select *
    from sashelp.class as a
	  left join class2 as b 
	    on a.name = b.name;
quit;

proc print data=class_c;
run;
	    
proc sql;
create table class_d as
  select *
    from class2 as a
	  right join sashelp.class as b 
	    on a.name = b.name;
quit;

proc print data=class_d;
run;

```

#### Full join

```{r,engine="sas",error=TRUE}
data class2;
input name $   score;
datalines;
Alfred 	85
Alice 89
Daniel 99
;
run;
 
proc sql;
create table class_e as
  select *
    from sashelp.class as a
	  full   join class2 as b 
	    on a.name = b.name;
quit;

proc print data=class_e;
run;

```

#### DATA step merge (append-style merge by key)

```{r,engine="sas",error=TRUE}
data class2;
input name $   score;
datalines;
Alfred 	85
Alice 89
Daniel 99
;
run;
 
data class_f;
merge  sashelp.class class2;
by name;
/*if A and B;  */
run;

proc print data=class_f;
run;

```

#### Inner join

```{r,engine="sas",error=TRUE}
data class2;
input name $   score;
datalines;
Alfred 	85
Alice 89
Daniel 99
;
run;
 
proc sql;
create table class_e as
  select *
    from sashelp.class as a
	  inner join class2 as b 
	    on a.name = b.name;
quit;

proc print data=class_e;
run;

```

#### Minus join (anti-join)

```{r,engine="sas",error=TRUE}
data class2;
input name $   score;
datalines;
Alfred 	85
Alice 89
Daniel 99
;
run;
 
proc sql;
create table class_e as
  select *
    from sashelp.class as a
	  left join class2 as b 
	    on a.name = b.name 
	    where b.name is NULL;
quit;

proc print data=class_e;
run;
```

This is the SAS SQL equivalent of “keep rows in A that do not match B”.

---

### Create Table 1

In clinical reporting, “Table 1” typically summarizes baseline demographics and characteristics by treatment group.

Your code calls external macro files via `%include`.  
This is a realistic production pattern: statistical programming teams maintain shared macro libraries, and analyses import them.

```{r , engine="sas" , error=TRUE}
  *** Load utility macros;
%include "C:\Users\hed2\Downloads\mybook2\mybook2\sasmacro\create_table1.sas";

  *** Specify input and output data sets, and the column variable.;
%let INPUT_DATA  = sashelp.class;
%let OUTPUT_DATA = Table1 ;
%let COLVAR      = sex;

  /*chort*/
 *** %AddText(text=Height);
 *** %CategoricalRowVar2(rowVar=);
%ContinuousRowVar2(rowVar=height );
 *** %AddText(text=);

%ContinuousRowVar2(rowVar=weight );
%ContinuousRowVar2(rowVar=Age );

proc print data= table1;
run;

/* Export Table 1 as a CSV file*/ 
proc export data=Table1 replace label
    outfile="C:\Users\hed2\Downloads\mybook2\mybook2\sasmacro\table1.csv"
    dbms=csv;
run;  

```

Interpretation:
- Macro calls like `%ContinuousRowVar2(...)` likely append rows into the Table 1 dataset.
- `proc export` creates a portable deliverable (CSV) for review, QA, or publication workflows.

---

## Using macros

Macros are the “automation layer” of SAS. They help you:
- avoid copy/paste,
- standardize reports,
- scale analyses to many endpoints/variables.

#### Create a macro variable from a statistic

```{r , engine="sas" , error=TRUE}
proc sql noprint; 
select  std(age) format=best32.
   into :age_mean
   from sashelp.class;
quit;
   
%put Mean of age: &age_mean;
%putlog Mean of age: &age_mean;
```

This is a standard trick:
- compute something with PROC SQL,
- store into a macro variable,
- reuse it later in titles, footnotes, conditions, or other macros.

---

#### Select variable names from metadata

SAS metadata tables (`dictionary.columns`) are extremely powerful for programmatic workflows.

```{r , engine="sas" , error=TRUE}
proc sql;
     select name
           into :vars separated by ' '
            from dictionary.columns
              where libname="SASHELP" and
                memname="CLASS" and varnum=4;
   ;
quit;
%put &vars.;
```

This pattern is the foundation of “dynamic programming” in SAS:
- detect variables automatically,
- loop over them,
- generate consistent outputs.

---

#### Iterative DO loops

DATA step loops are for row-by-row computations and simulation-like constructions.

```{r , engine="sas" , error=TRUE}
data do_to;
   x=10;
   y="yes";
   do i=1 to 10;
      x=x+1;
      output;
   end;
run;
proc print data=do_to;
run;
```

`do while` loops are useful for process-like simulations:

```{r , engine="sas" , error=TRUE}
data loan;
   balance=1000;
   payment=0;
   do while (balance>0);
      balance=balance-100;
      payment=payment+1;
      output;
   end;
run;
proc print data=loan;
run;
```

---

#### DO loop inside a macro

This example illustrates how macros generate SAS code and then run it.

```{r , engine="sas" , error=TRUE}
%macro run_calculation(amt, t, r);
    data customer_value;
        i=&r./10.;
        do n=0 to &t.;
            S=&amt.*((1+i)*n - 1)/i;  /*Power operator */
            output; /*output s*/
        end;
   file print;
   putlog  s @@;
   put  s @@;
    run;
proc print data=customer_value;
run;
%mend;

%run_calculation(amt=100, t=10, r=7);
```

Even when the formula is toy-like, the structure mirrors production macro design:
- macro parameters define the scenario,
- data step creates a dataset,
- output is printed or reported.

---

### PROC REPORT for flexible summaries

Here we generate a summary dataset with `proc means`, then format it with `proc report`.

```{r , engine="sas" , error=TRUE}
proc means data=sashelp.class;
var _NUMERIC_;  /*_CHARACTER_*/
output out=want mean= sum= max= /autoname;
run;

proc report data= want;
Column _FREQ_;
Column Age_Mean;
Column Age_Sum;
Column Age_max;
Define _FREQ_  /"The total number" display;
Define Age_mean  /"Mean of age" display;
Define Age_sum  /"Sum of age" display;
Define Age_max  /"Max of age" display;
Run;
```

Teaching point:
- `proc means` creates the statistics,
- `proc report` controls presentation.

This split is clean and scalable.

---

## Use SAS formats

Formats provide consistent labeling, grouping, and display standards—especially important in regulated reporting.

#### Creating labels for different values

```{r , engine="sas" , error=TRUE}
PROC FORMAT;
    VALUE LIKERT7_A
	  1,2,3   = "Disagree"
	  4       = "Neither Agree nor Disagree"
	  5,6,7   = "Agree"
RUN;

PROC FORMAT;
    VALUE INCOME
	  LOW   -< 20000 = "Low"
	  20000 -< 60000 = "Middle"
	  60000 - HIGH   = "High";
RUN;

PROC FORMAT;
    VALUE RACE
       1     = "White"
       2     = "Black"
       OTHER = "Other";
RUN;

PROC FORMAT;
    VALUE $GENDERLABEL
	  "M"   = "Male"
	  "F"   = "Female";
RUN;

DATA sample;
    SET sashelp.class;
    FORMAT sex GENDERLABEL. ;
RUN;

proc freq data=sample;
table sex;
run;
```

Formats are not only cosmetic—they also define category behavior in many procedures.

---

### Storing formats to a library

When you create formats in `work`, they disappear after the session ends.  
A permanent format library allows reuse across projects and reports.

#### Way 1: store in a dedicated format library and use `FMTSEARCH`

```{r , engine="sas" , error=TRUE}
LIBNAME format  "C:\Users\hed2\Downloads\code-storage\code\format";

PROC FORMAT LIBRARY=format ;
    VALUE $GENDER
	  "M"   = "Male_new"
	  "F"   = "Female_new";
RUN;
 
OPTIONS FMTSEARCH=(format);
DATA sample;
    SET sashelp.class;
    FORMAT sex GENDER. ;
RUN;

proc freq data=sample;
table sex;
run;
```

Interpretation:
- `LIBNAME format` points to a permanent folder.
- `PROC FORMAT LIBRARY=format` stores formats there.
- `FMTSEARCH` tells SAS where to look for formats.

---

#### Way 2: include a SAS file that defines formats

```{r , engine="sas" , error=TRUE}
%INCLUDE 'C:\Users\hed2\Downloads\code-storage\code\format\format_test.sas';
DATA sample;
    SET sashelp.class;
    FORMAT sex GENDERsex. ;
RUN;

proc freq data=sample;
table sex;
run;
```

This is common in shared programming environments:
- formats are maintained in version-controlled `.sas` files,
- projects include them as needed.

---

#### Way 3: add formats to an existing format library

```{r , engine="sas" , error=TRUE}
 LIBNAME format  "C:\Users\hed2\Downloads\code-storage\code\format";

PROC FORMAT LIBRARY=format ;
    VALUE $GENDER
	  "M"   = "Male_new"
	  "F"   = "Female_new";
RUN;

PROC FORMAT LIBRARY=format ;
  VALUE $gendersextwo
	  "M"   = "Male_new2_two"
	  "F"   = "Female_new2_two";
RUN;
	  
OPTIONS FMTSEARCH=(format);
DATA sample;
    SET sashelp.class;
    FORMAT sex GENDERsextwo. ;
 RUN;

proc freq data=sample;
table sex;
run;
```

This demonstrates that format libraries are extendable: you can keep adding definitions over time.

---

#### Way 4: apply formats in batch via `%include`

```{r , engine="sas" , error=TRUE}
LIBNAME format  "C:\Users\hed2\Downloads\code-storage\code\format";

PROC FORMAT LIBRARY=format ;
    VALUE $GENDER
	  "M"   = "Male_new"
	  "F"   = "Female_new";
RUN;

OPTIONS FMTSEARCH=(format);
DATA sample;
    SET sashelp.class;
%INCLUDE 'C:\Users\hed2\Downloads\code-storage\code\format\use_format.sas';
RUN;

proc freq data=sample;
table sex;
run;
```

This pattern is helpful when:
- many variables require formatting,
- format assignment rules are long,
- you want to keep the main analysis code clean.

---

### Modify formats

User-defined formats cannot be edited “in place” like a database table; you typically redefine them.  
Your example also shows using `other=` to handle all remaining values.

```{r, engine="sas" , error=TRUE}
/*User-defined formats cannot be edited. to create a macro by myself ; or proc freq then use excel*/; 
PROC FORMAT ;
    VALUE $GENDER
	  "M"   = "Male_new"
	  "F"   = "Female_new";
RUN;
proc format;
	  value $sex_f  "F"="Female_f" other=[5.1];	
run;

DATA sample;
    SET sashelp.class;
    FORMAT sex $sex_f. ;
 RUN;

proc freq data=sample;
table sex;
run;
```

---

### Transform missing to character then to numeric again

This technique appears in recoding tasks where you need numeric categories but start from character labels.

```{r, engine="sas" , error=TRUE}
PROC FORMAT ;
    VALUE $num
	  "M"   = 1
	  "F"   = 2;
RUN;

DATA sample_2; 
  SET sashelp.class;
  sex_2 = input(put(sex ,num.),best.);  /*Converting variable types and keep*/
RUN;
proc freq data=sample_2;
table sex_2;
run;
```

Mechanism:
- `put(sex, num.)` maps "M"/"F" to "1"/"2" as character,
- `input(..., best.)` converts that character into numeric.

---

### Output format definition details

When you need to inspect what a format contains, you can output it.

```{r, engine="sas" , error=TRUE}
PROC FORMAT ;
    VALUE $GENDER
	  "M"   = "Male_new"
	  "F"   = "Female_new";
RUN;

proc format library = work.formats FMTLIB cntlout = cntlout;
select $GENDER;
run;
```

This creates `cntlout`, which is a dataset representation of the format—useful for QA and documentation.

---

### A macro to copy an existing PROC FORMAT

This longer macro demonstrates a common real need: reconstruct a format definition programmatically (for reuse, reporting, or migration).

```{r, engine="sas" , error=TRUE}
%macro formatd(data, var);
data temp;
set &data;
keep &var;
run;

/*original freq*/
ods output  OneWayFreqs=sample_b  ;
proc freq data=temp  ;
table  &var /missing ;
run;
ods output close;
 
/*delete format freq*/
data sample2;
set  temp;
Format _all_;
run;
proc freq data=sample2   ;
table  &var /missing out=sample_c ;
run;

/*select original variable code*/
proc sql noprint;
          select name into :firstvar_b from dictionary.columns where libname='WORK' and memname='SAMPLE_B'
          and varnum=2;
quit;
data sample_b2;
set sample_b;
Keep &firstvar_b ;
run;

/*select original variable label*/
proc sql noprint;
          select name into :firstvar_c from dictionary.columns where libname='WORK' and memname='SAMPLE_C'
          and varnum=1;
quit;
data sample_c2;
set sample_c;
Keep &firstvar_c  ;
run;

/*merge variable code and label*/
data sample_bc;
set sample_b2 (RENAME=(&firstvar_b=new_b));
set sample_c2 (RENAME=(&firstvar_c=new_c));
run;

/*create format format and output*/
data sample_bc;
set sample_bc;
Original_format = CATS(new_c,"=","'",new_b,"'");
run;

proc print data=sample_bc noobs;
   var Original_format;
run;

%mend formatd;


PROC FORMAT ;
    VALUE $GENDER
	  "M"   = "Male_new"
	  "F"   = "Female_new";
RUN;
DATA sample;
    SET sashelp.class;
    FORMAT sex $GENDER. ;
 RUN;

%formatd(sample, sex   );
```

Reading the intent:
- `sample_b` captures formatted labels (via ODS output from PROC FREQ).
- `sample_c` captures raw unformatted codes.
- The macro merges them to reconstruct mapping rules like `"Male_new"='M'`.

This is a clever QA/automation trick when you inherit legacy formats but need documentation.

---

### A macro to view the list of variables

Finally, a compact utility macro to list variable names in a dataset.

```{r,engine='sas',error=TRUE}
%macro varnames (dat);
proc contents
     data = &dat
          noprint
          out = data_info
               (keep = name );
run;
proc print
     data = data_info
          noobs;
run;
%mend;
%varnames (sashelp.class) 
```

This is particularly helpful inside SASmarkdown documents because it provides quick visibility when you cannot “click around” like in SAS Studio.

---

### Practical workflow recommendations for SASmarkdown

When you write SAS inside R Markdown, the biggest productivity gains come from being explicit:

1) **Make each SAS chunk self-contained**, or write intermediate datasets to a permanent library.  
2) **Use ODS OUTPUT** whenever you need a procedure result as a dataset for downstream steps.  
3) **Prefer PROC SQL joins** for clarity unless you specifically need DATA step merge behavior.  
4) **Store formats in a permanent library** if the report will be knitted repeatedly.

With these habits, SASmarkdown becomes a reliable way to produce reproducible, publication-ready analysis documents that combine narrative, code, and output in one place.
